2022.4.13 블룸필터까지 복습
1. STORAGE, WORLD STATE
2. MEMORY(UNISWAP)
3. STACK
4. MESSAGECALL, DELEGATE CALL, 스마트 컨트랙트를 업그레이드하는 기법 (USDC)-11PAGE부분 학습
5. 블룸필터(라이트 클라이언트)
6. 컴파일러 최적화 옵션(반드시 실행)

<br>
이더리움 가상머신은 스마트 컨트랙트를 위한 런타임 환경
완전히 고립된 공간에서만 정해진 대로 동작한다.
연산, 데이터 저장
롬, 스토리지, 메모리, 스택
블록체인 상에 있는 정보는 영구히 기록되기 때문에 신중해야 한다.
스토리지에 저장하는 것은 비용이 많이 든다.
연산력에 비례하게 가스비를 지불한다. 
사용자가 보낸 가스비를 벗어나면 수행을 취소한다.
스토리지에 접근한다는 것은 내 스마트 컨트랙트의 저장공간에 접근
월드 스테이트는 다른 스마트 컨트랙트의 상태, 혹은 계정의 상태에 접근하는 것이기 때문에 message call사용.
롬은 가상머신에서 수행될 때 수정되면 안된다. 때문에 읽기 전용 저장 공간인 롬에서 수행한다.<br>

**storage와 state<br>
storage, state를 쓰는 연산의 비용은 매우 비싸다.
이것들은 영구히 기록하기 때문이다.
이 두 가지를 읽기을 경우에도 크다.
그 이유는 저장하고 있는 데이터 용량이 크다 보니 데이터를 찾는데 많은 연산이 필요하다.
이런 문제를 해결하기 위해 스토리지를 줄이는 노력이 지속되고 있다.
이더리움의 state expired등이 있다.
256bit 단위로 읽어온다. 스마트 컨트랙트 사용시 한 번에 다 읽어올 수 있도록 스마트 컨트랙트를 작성한다.<br>

**스마트 컨트랙트는 storage와 state를 변화시킨다.<br>
world state = event를 통해 스마트 컨트랙트를 통해 데이터를 바꿀 수 있다.
하지만 이 연산의 경우 비용이 크기 때문에 이것을 최적화시키는 것이 중요하다.
안전하게, 효율적으로 작성해야 한다.<br>

**memory도 마음대로 쓰면 안된다.<br>
256비트를 단위로 확장 가능하다. 확장마다 가스가 쿼드라틱하게 증가한다.
메모리 절감 기법 필요함.<br>

**대표적인 케이스가 유니스왑이다.<br>
유니스왑이 각광 받았던 이유가 저렴한 수수료 덕분이다.
기존의 방식은 오더북으로 스토리지 참고가 많았다. 하지만 유니스왑은 그것을 최소화한다.
##없어도 되는 {}가 있다. 이렇게 SCOPE를 쓰게 되면 해당 중괄호를 벗어나면 메모리가 해제된다.
때문에 메모리를 최적화할 수 있다.<br>

**스택 깊이 최대 제한에 걸리지 않도록 한다.<br>
최대 스택 사이즈는 1024개의 요소가 있따.
모든 연산은 스택에서 이루어짐.
EVM은 스택 머신이다.<br>

**MESSAGE CALL, DELEGATE CALL<br>
스마트 컨트랙트가 스마트 컨트랙트를 호출하는 로직을 사용할 때 사용됨.
컨트랙트가 아닌 주소에 이더 전송 가능.
트랜잭션과 유사하다. 
call payload(call data의 또 하나의 분리된 영역)에 접근할 수 있음. 데이터를 반환하면 caller의 메모리에 저장됨.
call역시1024의 스택 깊이로 제한됨. =>재귀함수보다는 반복문 사용이 좋음.
호출된 컨트랙트는 freshly cleared 메모리 인스턴스를 가짐.
모든 컨트랙트의 시작점은 EOA이다.
CA는 컨트랙트 계정이다.
MSG.SENDER문제
컨트랙트 2번에서 MSG.SENDER는 EOA가 아니라 CONTRACT1이 SENDER가 된다.
만약 EOA가 SENDER가 되고 싶다면?
이때 DELEGATE CALL을 사용하면 된다? 이것은 잘못된 설명이다.
이것은 CA2에 넘겨서 실행하는 것이 아니라 CA2의 코드를 CA1을 가져와 실행하는 것이다.
DELEGATECALL을 사용하면 컨트랙트 업그레이드가 가능하다.
CA2를 바꾸면 된다. CA3를 만들어 적용할 수 있다. 
이렇게 구현하면 CA1의 스토리지를 쓰면서 로직만 CA2만 바꿀 수 있다.
대표적인 예시가 USDC이다.
라이브러리는 무조건 delegate call형식으로 가져온다.<br>

**log, <br>
솔리디티에서 이벤트를 통해 구현할 수 있음.
데이터를 블록 레벨에 저장할 수 있는 방법.
솔리디티에서 이벤트를 통해 구현할 수 있음.
https://etherscan.io/address/0xd5d86fc8d5c0ea1ac1ac5dfab6e529c9967a45e9#events
컨트랙트에 로그를 남기면 로그 데이터에는 접근 불가하다.<br>


**블룸필터<br>https://medium.com/@naterush1997/eth-goes-bloom-filling-up-ethereums-bloom-filters-68d4ce237009

 = 특정 원소가 집합에 속하는지 검사하는데 사용할 수 있는 확률형 자료 구조.
집합의 크기가 굉장히 크거나 집합의 속해있는 원소의 크기가 커서 원소가 집합에 속해있는지 정확히 판단하는데 시간이 오래걸리는 경우 이 과정의 전처리 과정으로 Bloom Filter를 이용해서 아예 집합에 속할 일이 없는 원소를 미리 걸러낼 수 있다.
블록체인은 거대한 데이터베이스이기 때문에 매우 많은 양의 데이터가 포함되어 있습니다. 블록체인의 일부만 참조하고 제한된 검증을 지원하는 가벼운 클라이언트를 상상해 보십시오. 일반 클라이언트는 라이트 클라이언트의 주소 집합을 블룸 필터로 표시함으로써 트랜잭션을 라이트 클라이언트에 전달할지 여부를 결정할 수 있습니다.
이더리움에서 모든 토큰 전송은 이벤트-로그를 시작하도록 요구하고 이런 이벤트는 각 블록의 일부인 블룸 필터에 저장된다.
노드에 알려지지 않은 거래를 식별하는 데 도움을 준다.
이더리움 블록 헤더에 있는 데이터이다.
라이트 클라이언트도 로그를 찾을 수 있도록 하는 자료구조.
512bit의 배열이 있다. 어떤 이벤트가 발생하면 3갈래로 해시를 취한다. 
서로 다른 해시함수로 해시를 취함.
해당 해시 함수는 0~512까지의 범위를 가진다. 대응되는 인덱스를 1로 바꾼다.
이런 방식을 사용하면 특정 데이터가 데이터에 참여했나 안했냐를 확인할 수 있다.
멤버십 부재에 대한 검증만 가능하다.
라이트 클라이언트는 블록을 검증하는 역할을 하게 됨.
어떤 데이터가 없었다 정도는 라이트 클라이언트로도 충분히 가능하다.
dapp을 만들 경우 직접 노드를 운영해야 한다.(제3자를 이용하는 것도 가능하지만 이것은 제한적이다.)
이때 라이트 클라이언트로 가능할 수도 있다.
라이트 클라이언트는 매우 중요하다.
<br>

**컴파일러 최적화 옵션<br>
솔리디티는 하이레벨 언어임
때문에 이를 줄이는 컴파일 해줌
이때 컴파일 최적화 옵션 무조건 켜야 함.<br>

**the dao 해킹 이슈<br>
fallback function 
이더를 withdraw 하는 주체를 컨트랙트 주소로 했다.
리앤트런치 공격<br>

**mapping<br>
동적 어레이같은 경우 데이터가 빠지면 앞으로 끌어와야 해서 비효율적이다.
때문에 mapping을 쓰는 것이 효율적이고
반복문 사용도 줄기 때문에 효율적인 개발이 가능하다.<br>